<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Jochua Simulator | Full Details & Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Orbitron', sans-serif; }
        #hud { 
            position: absolute; top: 30px; left: 30px; 
            color: #fff; border-left: 6px solid #fff; padding-left: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: none; z-index: 10;
        }
        .stat { font-size: 56px; font-weight: 900; line-height: 0.9; }
        .label { font-size: 14px; opacity: 0.8; letter-spacing: 5px; text-transform: uppercase; margin-bottom: 5px; }
        #flash { position: absolute; inset: 0; background: red; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.1s; }
        #controls { position: absolute; bottom: 20px; left: 30px; color: white; font-size: 11px; opacity: 0.8; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="flash"></div>
    <div id="hud">
        <div class="label">Jochua Simulator</div>
        <div class="stat"><span id="speed-val">0</span> <small style="font-size: 20px;">KM/H</small></div>
    </div>
    <div id="controls">
        Z/S: Gaz/Reculer | A: Cligno G | E: Cligno D | G: Warnings | L: Phares<br>
        <b>TOUT EST LÀ : Détails, Terrain, Drift et Poteaux !</b>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, car, worldGroup, wheels = [];
        let obstacles = [], particles = [], headlightProjections = [], taillightProjections = [];
        let meshHeadL, meshHeadR, meshRearL, meshRearR, meshBlinkL, meshBlinkR;
        
        let speed = 0, angle = 0, driftAngle = 0;
        let lightsOn = false, blinkTimer = 0, blinkMode = 0; 
        const keys = {};

        const MAX_SPEED_FWD = 1.1; 
        const ACCEL = 0.00065; 
        const FRICTION = 0.0025;
        const STEER_SPEED = 0.028;
        const WORLD_SIZE = 20000;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 400);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(50, 100, 50);
            scene.add(sun);

            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            // --- LE TERRAIN (REMIS) ---
            const road = new THREE.Mesh(new THREE.PlaneGeometry(25, WORLD_SIZE), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            road.rotation.x = -Math.PI / 2; road.position.z = -WORLD_SIZE/2 + 50;
            worldGroup.add(road);
            
            for(let i = 0; i < 500; i++) {
                const line = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
                line.rotation.x = -Math.PI / 2; line.position.set(0, 0.05, -i * 50);
                worldGroup.add(line);
            }

            const plainL = new THREE.Mesh(new THREE.PlaneGeometry(1000, WORLD_SIZE), new THREE.MeshStandardMaterial({color: 0x228B22}));
            plainL.rotation.x = -Math.PI / 2; plainL.position.set(-512.5, -0.01, -WORLD_SIZE/2 + 50);
            worldGroup.add(plainL);
            const plainR = plainL.clone(); plainR.position.x = 512.5; worldGroup.add(plainR);

            // --- OBSTACLES ---
            for(let i = 0; i < 35; i++) {
                const obs = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 15, 16), new THREE.MeshStandardMaterial({color: 0xff0000}));
                obs.position.set(Math.random() * 40 - 20, 7.5, -i * 120 - 100);
                worldGroup.add(obs);
                obstacles.push(obs);
            }

            // --- LA BMW JOCHUA (DÉTAILS COMPLETS REMIS) ---
            car = new THREE.Group();
            car.position.y = 1.1; scene.add(car);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.9, roughness: 0.1 });
            const chromeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 1 });
            const offLightMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

            car.add(new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.6, 4.8), bodyMat));
            const roof = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2.6), glassMat);
            roof.position.set(0, 0.5, 0.1); car.add(roof);

            // Calandre Double Rein
            const gL = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.5, 0.1), chromeMat);
            gL.position.set(0.3, -0.05, -2.4);
            const gR = gL.clone(); gR.position.x = -0.3; car.add(gL, gR);

            // Rétros et Aileron
            const mirL = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.2), bodyMat);
            mirL.position.set(1.25, 0.4, -0.8);
            const mirR = mirL.clone(); mirR.position.x = -1.25; car.add(mirL, mirR);
            const wing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.05, 0.8), bodyMat);
            wing.position.set(0, 0.65, 2.2); car.add(wing);

            // 4 Pots
            for(let x of [-0.6, -0.4, 0.4, 0.6]) {
                const ex = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.4), chromeMat);
                ex.rotation.x = Math.PI/2; ex.position.set(x, -0.2, 2.4); car.add(ex);
            }

            // LUMIÈRES ET PROJECTIONS
            meshHeadL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.1), offLightMat.clone());
            meshHeadL.position.set(0.85, 0.1, -2.4);
            meshHeadR = meshHeadL.clone(); meshHeadR.position.x = -0.85; car.add(meshHeadL, meshHeadR);

            const spotL = new THREE.SpotLight(0xffffff, 0, 80, 0.5, 0.5);
            spotL.position.set(0.85, 0.1, -2.4);
            const spotR = spotL.clone(); spotR.position.x = -0.85;
            car.add(spotL, spotR, spotL.target, spotR.target);
            spotL.target.position.set(0.85, 0, -30); spotR.target.position.set(-0.85, 0, -30);
            headlightProjections = [spotL, spotR];

            meshRearL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.1), offLightMat.clone());
            meshRearL.position.set(0.85, 0.1, 2.4);
            meshRearR = meshRearL.clone(); meshRearR.position.x = -0.85; car.add(meshRearL, meshRearR);

            const pL = new THREE.PointLight(0xff0000, 0, 12); pL.position.set(0.85, 0.1, 2.5);
            const pR = pL.clone(); pR.position.x = -0.85; car.add(pL, pR); 
            taillightProjections = [pL, pR];

            meshBlinkL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.1), offLightMat.clone());
            meshBlinkL.position.set(0.85, 0.25, -2.41);
            meshBlinkR = meshBlinkL.clone(); meshBlinkR.position.x = -0.85; car.add(meshBlinkL, meshBlinkR);

            const wPos = [[1.15, -0.4, 1.7], [-1.15, -0.4, 1.7], [1.15, -0.4, -1.7], [-1.15, -0.4, -1.7]];
            wPos.forEach(pos => {
                const w = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.45, 24), new THREE.MeshStandardMaterial({color: 0x111111}));
                w.rotation.z = Math.PI/2; w.position.set(...pos); wheels.push(w); car.add(w);
            });

            animate();
        }

        function spawnPart(x, y, z, color = 0xcccccc) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.2, 6, 6), new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.5}));
            const wp = new THREE.Vector3(x, y, z).applyMatrix4(car.matrixWorld);
            p.position.copy(wp); scene.add(p); particles.push({ mesh: p, life: 1.0 });
        }

        window.onkeydown = (e) => {
            keys[e.code] = true;
            if(e.code === 'KeyL') lightsOn = !lightsOn;
            if(e.code === 'KeyA') blinkMode = (blinkMode === 1) ? 0 : 1;
            if(e.code === 'KeyE') blinkMode = (blinkMode === 2) ? 0 : 2;
            if(e.code === 'KeyG') blinkMode = (blinkMode === 3) ? 0 : 3;
        };
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);
            let accel = keys['ArrowUp'] || keys['KeyW'];
            let brake = keys['ArrowDown'] || keys['KeyS'];

            if(accel) { if(speed < MAX_SPEED_FWD) speed += ACCEL; } 
            else if(brake) { if(speed > -0.5) speed -= ACCEL * 2; } 
            else { speed *= (1 - FRICTION); }

            let steer = 0;
            if(keys['ArrowLeft'] || keys['KeyA']) steer = STEER_SPEED;
            if(keys['ArrowRight'] || keys['KeyD']) steer = -STEER_SPEED;

            angle += steer * (speed * 0.8 + 0.2); 
            driftAngle += (angle - driftAngle) * (accel ? 0.15 : 0.08);
            car.rotation.y = driftAngle;
            worldGroup.position.z += Math.cos(angle) * speed * 10;
            worldGroup.position.x += Math.sin(angle) * speed * 10;

            // RECYCLAGE POTEAUX
            obstacles.forEach(obs => {
                const wp = new THREE.Vector3(); obs.getWorldPosition(wp);
                if(wp.z > 50) {
                    obs.position.z -= 600; 
                    obs.position.x = Math.random() * 40 - 20;
                }
                if(Math.sqrt(wp.x**2 + wp.z**2) < 2.5) {
                    document.getElementById('flash').style.opacity = '1';
                    setTimeout(() => document.getElementById('flash').style.opacity = '0', 150);
                    speed = 0; 
                }
            });

            // GESTION LUMIÈRES
            headlightProjections.forEach(l => l.intensity = lightsOn ? 150 : 0);
            meshHeadL.material.color.set(lightsOn ? 0xffffff : 0x333333);
            meshHeadR.material.color.set(lightsOn ? 0xffffff : 0x333333);
            taillightProjections.forEach(l => l.intensity = brake ? 40 : 0);
            meshRearL.material.color.set(brake ? 0xff0000 : 0x333333);
            meshRearR.material.color.set(brake ? 0xff0000 : 0x333333);

            blinkTimer += 0.05;
            const b = Math.sin(blinkTimer * 3.14) > 0;
            meshBlinkL.material.color.set(((blinkMode===1 || blinkMode===3) && b) ? 0xffaa00 : 0x333333);
            meshBlinkR.material.color.set(((blinkMode===2 || blinkMode===3) && b) ? 0xffaa00 : 0x333333);

            // DRIFT FUMÉE
            if(Math.abs(angle - driftAngle) > 0.06 && Math.abs(speed) > 0.4) {
                spawnPart(1.1, -0.4, 1.7, 0x333333); spawnPart(-1.1, -0.4, 1.7, 0x333333);
            }

            particles.forEach((p, i) => {
                p.life -= 0.02; p.mesh.material.opacity = p.life; p.mesh.position.y += 0.02;
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            });

            wheels.forEach(w => w.rotation.x -= speed * 2.5);
            document.getElementById('speed-val').innerText = Math.round(Math.abs(speed) * 180);
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
